{"version":3,"file":"bundle.js","mappings":"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","sources":[".././node_modules/picomatch/index.js",".././node_modules/picomatch/lib/constants.js",".././node_modules/picomatch/lib/parse.js",".././node_modules/picomatch/lib/picomatch.js",".././node_modules/picomatch/lib/scan.js",".././node_modules/picomatch/lib/utils.js","../webpack/bootstrap","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../external commonjs \"vscode\"",".././src/clipboardHelper.js","../external node-commonjs \"fs\"","../external node-commonjs \"path\"","../external node-commonjs \"os\"",".././src/structureFormatter.js",".././src/ignoreHelper.js",".././src/fileHelpers.js",".././src/main.js"],"sourcesContent":["'use strict';\n\nconst pico = require('./lib/picomatch');\nconst utils = require('./lib/utils');\n\nfunction picomatch(glob, options, returnState = false) {\n  // default to os.platform()\n  if (options && (options.windows === null || options.windows === undefined)) {\n    // don't mutate the original options object\n    options = { ...options, windows: utils.isWindows() };\n  }\n\n  return pico(glob, options, returnState);\n}\n\nObject.assign(picomatch, pico);\nmodule.exports = picomatch;\n","'use strict';\n\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst SEP = '/';\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR,\n  SEP\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,\n  SEP: '\\\\'\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(opts.windows);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.output = (prev.output || prev.value) + tok.value;\n      prev.value += tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(opts.windows);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = opts.windows;\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(utils.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","/*global navigator*/\n'use strict';\n\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.isWindows = () => {\n  if (typeof navigator !== 'undefined' && navigator.platform) {\n    const platform = navigator.platform.toLowerCase();\n    return platform === 'win32' || platform === 'windows';\n  }\n\n  if (typeof process !== 'undefined' && process.platform) {\n    return process.platform === 'win32';\n  }\n\n  return false;\n};\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n\nexports.basename = (path, { windows } = {}) => {\n  const segs = path.split(windows ? /[\\\\/]/ : '/');\n  const last = segs[segs.length - 1];\n\n  if (last === '') {\n    return segs[segs.length - 2];\n  }\n\n  return last;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"vscode\");","// src/clipboardHelper.js\nimport * as vscode from \"vscode\";\n\nexport const copyToClipboard = async (\n  text,\n  successMessage = \"📁 Copied to clipboard!\",\n  errorMessage = \"Failed to copy to clipboard.\"\n) => {\n  try {\n    await vscode.env.clipboard.writeText(text);\n    vscode.window.showInformationMessage(successMessage);\n  } catch (error) {\n    vscode.window.showErrorMessage(errorMessage);\n  }\n};\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"path\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"os\");","// src/structureFormatter.js\r\nimport os from \"os\";\r\n\r\n// Helper to format folder and file structure with icons and appropriate lines\r\nexport const formatStructure = (name, type, indent, isLast, hasChildren) => {\r\n  const folderIcon = \"📂\";\r\n  const fileIcon = \"📄\";\r\n  const icon = type === \"folder\" ? folderIcon : fileIcon;\r\n\r\n  // Handle line prefixes\r\n  const linePrefix = isLast ? \"┗ \" : \"┣ \";\r\n  const childIndent = isLast ? \"  \" : \"┃ \";\r\n\r\n  // Return formatted string\r\n  return `${indent}${linePrefix}${icon} ${name}${os.EOL}${\r\n    hasChildren ? `${indent}${childIndent}` : \"\"\r\n  }`;\r\n};\r\n\r\n// Function to format the root folder structure header with absolute path\r\nexport const formatRootFolder = (name, path) => {\r\n  const boxIcon = \"📦\";\r\n  const computerIcon = \"🖥️\";\r\n\r\n  return `${boxIcon} ${name}${os.EOL}${computerIcon}\\u00A0${path}${os.EOL}\\u00A0${os.EOL}`;\r\n};\r\n","// src/ignoreHelper.js\r\nimport path from \"path\";\r\nimport fs from \"fs\";\r\nimport picomatch from \"picomatch\";\r\n\r\n/**\r\n * Helper to filter ignored files using relative paths and custom ignore rules.\r\n */\r\nexport const filterIgnoredFiles = (\r\n  dir,\r\n  files,\r\n  workspaceRoot,\r\n  ignorePatterns = [],\r\n  fsModule = fs,\r\n  pathModule = path\r\n) => {\r\n  const preparedPatterns = prepareIgnorePatterns(ignorePatterns);\r\n\r\n  const filteredFiles = files.filter((file) => {\r\n    const isDir = fsModule.statSync(pathModule.join(dir, file)).isDirectory();\r\n\r\n    // Resolve the absolute path of the file.\r\n    const absoluteFilePath = pathModule.resolve(dir, file.replace(/\\/$/, \"\"));\r\n\r\n    // Compute the relative path from 'workspaceRoot' to the file.\r\n    let relativePath = pathModule.relative(workspaceRoot, absoluteFilePath);\r\n    relativePath = relativePath.replace(/\\\\/g, \"/\");\r\n\r\n    // Append '/' if it's a directory.\r\n    if (isDir && !relativePath.endsWith(\"/\")) {\r\n      relativePath += \"/\";\r\n    }\r\n\r\n    // Ignore empty paths.\r\n    if (!relativePath) {\r\n      relativePath = \".\";\r\n    }\r\n\r\n    // Check if the path is ignored.\r\n    const isIgnored = isPathIgnored(relativePath, preparedPatterns);\r\n\r\n    return !isIgnored;\r\n  });\r\n\r\n  return filteredFiles;\r\n};\r\n\r\n/**\r\n * Prepares the ignore patterns, handling negation and order.\r\n */\r\nconst prepareIgnorePatterns = (patterns) =>\r\n  patterns.map((pattern) => {\r\n    const isNegation = pattern.startsWith(\"!\");\r\n    const cleanPattern = isNegation ? pattern.slice(1) : pattern;\r\n    const matcher = picomatch(cleanPattern, { dot: true });\r\n\r\n    return {\r\n      pattern: cleanPattern,\r\n      matcher,\r\n      isNegation,\r\n    };\r\n  });\r\n\r\n/**\r\n * Checks if a given path is ignored based on the ignore patterns.\r\n */\r\nconst isPathIgnored = (relativePath, ignorePatterns) => {\r\n  let ignored = false;\r\n\r\n  for (const { matcher, isNegation } of ignorePatterns) {\r\n    const matches = matcher(relativePath);\r\n\r\n    if (matches) {\r\n      ignored = !isNegation;\r\n    }\r\n  }\r\n\r\n  return ignored;\r\n};\r\n","// src/fileHelpers.js\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport * as vscode from \"vscode\";\r\nimport { formatStructure, formatRootFolder } from \"./structureFormatter.js\";\r\nimport { filterIgnoredFiles } from \"./ignoreHelper.js\";\r\nimport os from \"os\";\r\n\r\n// Traverse folder structure, display folders first, and sort alphabetically\r\nconst traverseDirectory = (\r\n  dir,\r\n  workspaceRoot,\r\n  additionalIgnores = [],\r\n  indent = \"\",\r\n  isLast = false\r\n) => {\r\n  let structure = \"\";\r\n\r\n  // Get entries and apply filtering\r\n  let entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n  // Filter files based on ignore patterns\r\n  entries = filterIgnoredFiles(\r\n    dir,\r\n    entries.map((e) => e.name),\r\n    workspaceRoot,\r\n    additionalIgnores,\r\n    fs,\r\n    path\r\n  );\r\n\r\n  // Separate directories and files and sort them alphabetically\r\n  const directories = entries\r\n    .filter((entry) => fs.statSync(path.join(dir, entry)).isDirectory())\r\n    .sort();\r\n  const files = entries\r\n    .filter((entry) => fs.statSync(path.join(dir, entry)).isFile())\r\n    .sort();\r\n\r\n  // Traverse directories first\r\n  directories.forEach((directory, index) => {\r\n    const isLastDir = index === directories.length - 1 && files.length === 0;\r\n    const hasChildren = fs.readdirSync(path.join(dir, directory)).length > 0;\r\n    structure += formatStructure(\r\n      directory,\r\n      \"folder\",\r\n      indent,\r\n      isLastDir,\r\n      hasChildren\r\n    );\r\n    structure += traverseDirectory(\r\n      path.join(dir, directory),\r\n      workspaceRoot,\r\n      additionalIgnores,\r\n      `${indent}${isLastDir ? \"  \" : \"┃ \"}`,\r\n      isLastDir\r\n    );\r\n  });\r\n\r\n  // Traverse files\r\n  files.forEach((file, index) => {\r\n    const isLastFile = index === files.length - 1;\r\n    structure += formatStructure(file, \"file\", indent, isLastFile, false);\r\n  });\r\n\r\n  return structure;\r\n};\r\n\r\n// Function to get the folder structure\r\nexport const getFolderStructure = (dir, additionalIgnores = []) => {\r\n  const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri?.fsPath;\r\n  const absolutePath = path.resolve(dir);\r\n  const folderName = path.basename(dir);\r\n\r\n  // Log and show notification with root path\r\n  const message = `💥 Root Path: ${workspaceRoot}`;\r\n  console.log(message);\r\n  vscode.window.showInformationMessage(message);\r\n\r\n  // Format the root folder with absolute path and name of the current folder\r\n  let structure = formatRootFolder(path.basename(workspaceRoot), absolutePath);\r\n  structure += `📂 ${folderName}${os.EOL}`; // Include folder name\r\n  structure += traverseDirectory(dir, workspaceRoot, additionalIgnores);\r\n  return structure;\r\n};\r\n\r\n// Function to get folder structure and content (dummy example for now)\r\nexport const getFolderStructureAndContent = (dir, additionalIgnores = []) => {\r\n  const folderStructure = getFolderStructure(dir, additionalIgnores);\r\n  return folderStructure; // Modify logic as per requirement\r\n};\r\n\r\n// Function to copy file content with path (dummy example for now)\r\nexport const copyFileContentWithPath = (uri) => {\r\n  const filePath = uri.fsPath;\r\n  const fileContent = fs.readFileSync(filePath, \"utf-8\");\r\n  return `${filePath}${os.EOL}${fileContent}`;\r\n};\r\n\r\n// Function to copy root folder path\r\nexport const copyRootFolderPath = () => {\r\n  const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri?.fsPath;\r\n  return workspaceRoot\r\n    ? `📁 Root Path: ${workspaceRoot}`\r\n    : \"No workspace root found.\";\r\n};\r\n\r\n// Function to copy root folder structure\r\nexport const copyRootFolderStructure = (additionalIgnores = []) => {\r\n  const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri?.fsPath;\r\n  return workspaceRoot\r\n    ? getFolderStructure(workspaceRoot, additionalIgnores)\r\n    : \"No workspace root found.\";\r\n};\r\n","// src/main.js\r\n\r\nimport { copyToClipboard } from \"./clipboardHelper.js\";\r\nimport {\r\n  getFolderStructure,\r\n  getFolderStructureAndContent,\r\n  copyRootFolderPath,\r\n  copyRootFolderStructure,\r\n  copyFileContentWithPath,\r\n} from \"./fileHelpers.js\";\r\n\r\n// Example function to handle clipboard and folder structure logic\r\nexport const handleCopyFolderStructure = async (uri, additionalIgnores) => {\r\n  try {\r\n    const result = await getFolderStructure(uri.fsPath, additionalIgnores);\r\n    await copyToClipboard(result, \"📁 Folder structure copied successfully!\");\r\n  } catch (error) {\r\n    console.error(`Error copying folder structure: ${error.message}`);\r\n  }\r\n};\r\n\r\n// Function to handle copying folder structure and content\r\nexport const handleCopyFolderStructureAndContent = async (\r\n  uri,\r\n  additionalIgnores\r\n) => {\r\n  try {\r\n    const result = await getFolderStructureAndContent(\r\n      uri.fsPath,\r\n      additionalIgnores\r\n    );\r\n    if (result) {\r\n      await copyToClipboard(\r\n        result,\r\n        \"📁 Folder structure and content copied successfully!\"\r\n      );\r\n    } else {\r\n      console.error(\"Failed to retrieve folder structure and content.\");\r\n    }\r\n  } catch (error) {\r\n    console.error(\r\n      `Error copying folder structure and content: ${error.message}`\r\n    );\r\n  }\r\n};\r\n\r\n// Function to copy file content with path\r\nexport const handleCopyFileContentWithPath = async (uri) => {\r\n  try {\r\n    const result = await copyFileContentWithPath(uri);\r\n    await copyToClipboard(\r\n      result,\r\n      \"📝 File content with path copied successfully!\"\r\n    );\r\n  } catch (error) {\r\n    console.error(`Error copying file content: ${error.message}`);\r\n  }\r\n};\r\n\r\n// Function to handle root folder path copying\r\nexport const handleCopyRootFolderPath = () => {\r\n  const result = copyRootFolderPath();\r\n  copyToClipboard(result, \"📁 Root folder path copied successfully!\");\r\n};\r\n\r\n// Function to handle root folder structure copying\r\nexport const handleCopyRootFolderStructure = (additionalIgnores) => {\r\n  const result = copyRootFolderStructure(additionalIgnores);\r\n  copyToClipboard(result, \"📁 Root folder structure copied successfully!\");\r\n};\r\n"],"names":["pico","utils","picomatch","glob","options","returnState","windows","undefined","isWindows","Object","assign","module","exports","WIN_SLASH","WIN_NO_SLASH","DOT_LITERAL","SLASH_LITERAL","QMARK","END_ANCHOR","START_ANCHOR","DOTS_SLASH","POSIX_CHARS","PLUS_LITERAL","QMARK_LITERAL","ONE_CHAR","NO_DOT","NO_DOTS","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK_NO_DOT","STAR","SEP","WINDOWS_CHARS","MAX_LENGTH","POSIX_REGEX_SOURCE","alnum","alpha","ascii","blank","cntrl","digit","graph","lower","print","punct","space","upper","word","xdigit","REGEX_BACKSLASH","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REGEX_SPECIAL_CHARS_GLOBAL","REGEX_REMOVE_BACKSLASH","REPLACEMENTS","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKWARD_SLASH","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_GRAVE_ACCENT","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","extglobChars","chars","type","open","close","globChars","win32","constants","expandRange","args","sort","value","join","RegExp","ex","map","v","escapeRegex","syntaxError","char","parse","input","TypeError","opts","max","maxLength","Math","min","len","length","SyntaxError","bos","output","prepend","tokens","capture","PLATFORM_CHARS","EXTGLOB_CHARS","globstar","dot","nodot","qmarkNoDot","star","bash","noext","noextglob","state","index","start","consumed","prefix","backtrack","negated","brackets","braces","parens","quotes","removePrefix","extglobs","stack","prev","eos","peek","n","advance","remaining","slice","consume","num","append","token","negate","count","increment","push","decrement","pop","tok","isBrace","isExtglob","extglob","inner","extglobOpen","conditions","extglobClose","rest","extglobStar","includes","test","expression","fastpaths","negatedExtglob","backslashes","replace","m","esc","first","repeat","unescape","contains","wrapOutput","next","match","exec","slashes","posix","idx","lastIndexOf","pre","indexOf","keepQuotes","strictBrackets","nobracket","prevValue","literalBrackets","hasRegexChars","escaped","nobrace","outputIndex","tokensIndex","brace","dots","arr","range","i","unshift","comma","out","toks","t","nonegate","regex","noglobstar","prior","before","isStart","afterStar","after","strictSlashes","end","escapeLast","suffix","slashDot","create","str","source","scan","Array","isArray","fns","arrayMatcher","isMatch","isState","val","compileRe","makeRe","isIgnored","ignore","ignoreOpts","onMatch","onResult","matcher","returnObject","result","onIgnore","format","toPosixSlashes","matchBase","basename","Boolean","patterns","pattern","p","returnOutput","toRegex","parsed","flags","nocase","err","debug","isPathSeparator","code","depth","isPrefix","isGlobstar","Infinity","scanToEnd","parts","lastIndex","isBracket","isGlob","braceEscaped","finished","charCodeAt","noparen","base","removeBackslashes","maxDepth","prevIndex","isObject","isRegexChar","navigator","platform","toLowerCase","process","lastIdx","startsWith","path","segs","split","last","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","d","a","definition","key","o","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","require","_regeneratorRuntime","e","iterator","c","asyncIterator","u","define","configurable","writable","wrap","Generator","Context","makeInvokeMethod","tryCatch","arg","h","l","f","s","y","GeneratorFunction","GeneratorFunctionPrototype","getPrototypeOf","values","g","defineIteratorMethods","forEach","_invoke","AsyncIterator","invoke","_typeof","resolve","__await","then","callInvokeWithMethodAndArg","Error","done","method","delegate","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","resultName","nextLoc","pushTryEntry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","isNaN","displayName","isGeneratorFunction","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","keys","reverse","charAt","stop","rval","handle","complete","finish","delegateYield","asyncGeneratorStep","copyToClipboard","_ref","_callee","text","successMessage","errorMessage","_args","arguments","_context","vscode","clipboard","writeText","showInformationMessage","t0","showErrorMessage","apply","_next","_throw","_x","formatStructure","indent","isLast","hasChildren","icon","linePrefix","childIndent","concat","os","isPathIgnored","relativePath","ignorePatterns","_step","ignored","_iterator","_createForOfIteratorHelper","_step$value","isNegation","traverseDirectory","dir","workspaceRoot","additionalIgnores","structure","entries","fs","withFileTypes","files","fsModule","pathModule","preparedPatterns","cleanPattern","filter","file","isDir","statSync","isDirectory","absoluteFilePath","relative","endsWith","filterIgnoredFiles","directories","entry","isFile","directory","isLastDir","isLastFile","getFolderStructure","_vscode$workspace$wor","workspaceFolders","uri","fsPath","absolutePath","folderName","message","console","log","getFolderStructureAndContent","copyFileContentWithPath","filePath","fileContent","_asyncToGenerator","handleCopyFolderStructure","error","_x2","handleCopyFolderStructureAndContent","_ref2","_callee2","_context2","_x3","_x4","handleCopyFileContentWithPath","_ref3","_callee3","_context3","_x5","handleCopyRootFolderPath","_vscode$workspace$wor2","handleCopyRootFolderStructure","_vscode$workspace$wor3","copyRootFolderStructure"],"sourceRoot":""}